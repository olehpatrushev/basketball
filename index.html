<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js GLTF Example</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas" style="width: 100%; height: 100vh;"></canvas>
    <script>
        //window.addEventListener('DOMContentLoaded', function () {
        // Get the canvas element
        const canvas = document.getElementById('renderCanvas');

        const mainColor = '#00f6ff';

        // Generate the Babylon.js engine
        const engine = new BABYLON.Engine(canvas, true);

        let camera; // Declare camera variable in global scope

        const IS_DEV = false;

        const makeTextPlane = function(text, color) {
            const dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", {
                width: text.length * 20,
                height: 30
            }, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 0, 30, "bold 36px monospace", color, "transparent", true, true);
            const plane = BABYLON.MeshBuilder.CreatePlane("TextPlane", {
                width: text.length * 0.25,
                height: 0.5
            }, scene);
            plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.emissiveColor = new BABYLON.Color3(1, 1, 1);;
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        };

        const showAxis = function(size) {
            const axisX = BABYLON.Mesh.CreateLines("axisX", [
                BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
                new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
            ], scene);
            axisX.color = new BABYLON.Color3(1, 0, 0);
            const axisY = BABYLON.Mesh.CreateLines("axisY", [
                BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
                new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
            ], scene);
            axisY.color = new BABYLON.Color3(0, 1, 0);
            const axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
                new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
            ], scene);
            axisZ.color = new BABYLON.Color3(0, 0, 1);
        };

        // Create the scene
        const scene = (() => {
            // Create a basic Babylon Scene object
            const scene = new BABYLON.Scene(engine);

            // Create and position a free camera
            camera = new BABYLON.ArcRotateCamera("camera1", 10, 10, 10, BABYLON.Vector3(-8.5, 0.5, 0.8), scene);

            if (IS_DEV) {
                camera.setPosition(new BABYLON.Vector3(-10, -10, -100));
                camera.attachControl(canvas, true);
            }

            // Create a basic light, aiming 0, 1, 0 - meaning, to the sky
            const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            const markersRoot = new BABYLON.TransformNode("markersRoot", scene);

            const segmentsRoot = new BABYLON.TransformNode("segmentsRoot", scene);

            // Load the GLTF model
            BABYLON.SceneLoader.Append("./", "scene.gltf", scene, function() {
                runtime.loaded = true;

                if (!IS_DEV) {
                    // Do something with the scene after loading
                    const animation = new BABYLON.Animation("cameraAnimation", "position", 30,
                        BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

                    // Animation keys
                    const keys = [];
                    keys.push({
                        frame: 0,
                        //value: new BABYLON.Vector3(1.9, 3.6, 9.8) // Starting position
                        value: new BABYLON.Vector3(5, 3.5, 10) // Starting position
                    });
                    keys.push({
                        frame: 300,
                        //value: new BABYLON.Vector3(1.6, 10.3, 2) // Ending position
                        value: new BABYLON.Vector3(10, 4, -10) // Ending position
                    });
                    keys.push({
                        frame: 600,
                        //value: new BABYLON.Vector3(1.6, 10.3, 2) // Ending position
                        value: new BABYLON.Vector3(5, 3.5, 10) // Starting position
                    });

                    animation.setKeys(keys);

                    // Attach the animation to the camera
                    camera.animations.push(animation);

                    // Create an animation for the camera's target
                    const targetAnimation = new BABYLON.Animation("cameraTargetAnimation", "target", 30,
                        BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

                    const targetKeys = [];
                    targetKeys.push({
                        frame: 0,
                        value: new BABYLON.Vector3(-8.5, 0.5, 0.8) // Starting target
                    });
                    targetKeys.push({
                        frame: 300,
                        value: new BABYLON.Vector3(-7, 0.5, 0.8) // Ending target
                    });
                    targetKeys.push({
                        frame: 600,
                        value: new BABYLON.Vector3(-8.5, 0.5, 0.8) // Starting target
                    });


                    targetAnimation.setKeys(targetKeys);

                    // Attach the animation to the camera
                    camera.animations.push(targetAnimation);

                    // Run the animation
                    scene.beginAnimation(camera, 0, 600, true);
                }

                scene.getMeshByName('ball1').setEnabled(false);
                scene.getMeshByName('ball2').setEnabled(false);

                for (let i = 1; i <= 14; i++) {
                    scene.getMeshByName('segment_' + i).setEnabled(false);
                }

                IS_DEV && showAxis(100);

                IS_DEV && setUpSegments({
                    "segment_1": {
                        "missed": 10,
                        "made": 20
                    },
                    "segment_2": {
                        "missed": 0,
                        "made": 10
                    },
                    "segment_3": {
                        "missed": 10,
                        "made": 10
                    }
                })

                loadData("b0edea70-22e1-11eb-b93a-02420c129761", "shots");

                startLoop();
            });

            return scene;
        })();

        const logCameraParameters = function(camera) {
            console.log("Camera Position:", camera.position);
            console.log("Camera Alpha:", camera.alpha);
            console.log("Camera Beta:", camera.beta);
            console.log("Camera Radius:", camera.radius);
            console.log("Camera Target:", camera.target);
        };

        let runtime = {
            shots: [

            ],
            loaded: false
        };

        // Register a render loop to repeatedly render the scene
        const startLoop = () => {
            engine.runRenderLoop(function() {
                process();

                scene.render();

                //logCameraParameters(scene.activeCamera);
            });
        }

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function() {
            engine.resize();
        });

        // Optionally log camera parameters on key press (e.g., 'p' for print)
        window.addEventListener("keydown", function(event) {
            if (event.key === 'p') {
                logCameraParameters(scene.activeCamera);
            }
        });

        const process = function() {
            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            runtime.shots.every((shot) => {
                const newPosition = shot.curve.getPoints()[shot.animationIndex];
                shot.animationIndex++;

                if (shot.animationIndex >= shot.curve.getPoints().length) {
                    shot.animationIndex = 0;
                }

                if (shot.animationIndex > 0) {
                    if (!shot.missed) {
                        const contour = generateCircle(0.06, 0.06, 6, 'xy');
                        let path = [...shot.curve.getPoints()].splice(0, shot.animationIndex);
                        if (path.length > 1) {
                            if (path.length > 13) {
                                path = path.splice(-13);
                            }

                            if (shot.tracer) {
                                scene.removeMesh(shot.tracer, true);
                            }

                            shot.tracer = BABYLON.MeshBuilder.ExtrudeShape('ext0', {
                                shape: contour,
                                path: path
                            });

                            shot.tracer.material = new BABYLON.StandardMaterial("trackMat", scene);
                            shot.tracer.material.diffuseColor = BABYLON.Color3.FromHexString(mainColor);
                            shot.tracer.material.emissiveColor = BABYLON.Color3.FromHexString(mainColor);

                            shot.tracer.rotate(BABYLON.Axis.Y, Math.PI, BABYLON.Space.LOCAL);
                        }
                    }
                }

                return true;
            });
        }

        const prepareShot = function(shotData = {}) {
            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            let shot = {
                animationIndex: 0,
                missed: null,
                curve: null,
                marker: null,
                tracer: null
            };

            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            let x = parseInt(shotData.hsx);
            let y = parseInt(shotData.hsy);

            if (isNaN(x) || x <= -7620 || x >= 7620) {
                console.warn(`"x" must be integer between -7620 and 7620, ${x} given`);
                return;
            }
            if (isNaN(y) || y <= -1220 || y >= 14210) {
                console.warn(`"y" must be integer between -1220 and 14210, ${y} given`);
                return;
            }

            x = x / 1080;
            y = (y + 1220) / 1150;

            y = 13.374 - y;

            shot.missed = shotData.st == "MISS";

            let markerMaterial = new BABYLON.StandardMaterial("shotMat");

            let texture;

            if (shot.missed) {
                texture = new BABYLON.Texture("./tex/red_marker.png")
            } else {
                texture = new BABYLON.Texture("./tex/green_marker.png")
            }

            markerMaterial.diffuseTexture = markerMaterial.opacityTexture = markerMaterial.emissiveTexture = texture;

            const markersRoot = scene.getNodeById("markersRoot");
            const marker = BABYLON.MeshBuilder.CreatePlane("marker", {
                width: 1,
                height: 1
            }, scene);

            marker.material = markerMaterial;
            marker.position.set(-y, 0.13, -x);
            marker.setParent(markersRoot);
            marker.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.LOCAL);

            shot.marker = marker;

            const position = newV(y, 0.13, x);
            const distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y - 12.1, 2));
            const destination = new BABYLON.Vector3(12.1, 3.13, 0)
            const point1 = destination.clone().subtract(position)
            point1.y = 0;
            point1.normalize()
            point1.scaleInPlace(distance * .3)
            const control = destination.clone().subtract(point1)
            control.y = Math.max(6, distance / 3);

            shot.curve = BABYLON.Curve3.CreateCatmullRomSpline(
                [
                    position,
                    control,
                    destination
                ],
                Math.max(parseInt(distance) * 3, 30),
                false
            );

            return shot;
        }

        const clearShots = function() {
            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            runtime.shots.every((shot) => {
                if (shot.tracer) {
                    scene.removeMesh(shot.tracer, true);
                }

                if (shot.marker) {
                    scene.removeMesh(shot.marker, true);
                }
                return true;
            });

            runtime.shots = [];
        }

        const setUpSegments = function(data = {}) {
            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            for (let i = 1; i <= 14; i++) {
                scene.getMeshByName('segment_' + i).setEnabled(false);
            }

            const segmentsRoot = scene.getNodeById("segmentsRoot");
            segmentsRoot.getChildren().forEach(child => scene.removeMesh(child));

            for (const segmentName in data) {
                const segmentData = data[segmentName];
                const segmentMesh = scene.getMeshByName(segmentName);
                const stats = (segmentData.made - segmentData.missed) / segmentData.made;
                if (segmentData.made == 0) {
                    segmentMesh.setEnabled(false);
                } else {
                    segmentMesh.setEnabled(true);
                    segmentMesh.position.y = stats * 0.5 - 0.25;
                    if (stats < 0.5) {
                        segmentMesh.material.albedoColor.set(1, 0, 0);
                    } else {
                        segmentMesh.material.albedoColor.set(0, 0, 1);
                    }
                    const scoreText = makeTextPlane(`${segmentData.made - segmentData.missed}/${segmentData.made}`, "white", 1);
                    scoreText.setParent(segmentsRoot);
                    scoreText.position.copyFrom(segmentMesh.position);
                    scoreText.position.y = 1.3;
                    scoreText.position.x *= -1;
                    scoreText.rotate(BABYLON.Axis.Y, -Math.PI / 2, BABYLON.Space.LOCAL);
                }
            }
        }

        const setUpScreens = function(data = {}) {
            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            for (const screenId in data) {
                const screenMesh = scene.getMeshById(screenId);
                if (screenMesh) {
                    screenMesh.material.albedoTexture.updateURL(data[screenId]);
                    screenMesh.material.emissiveTexture.updateURL(data[screenId]);
                } else {
                    console.warn(`"${screenId}" mesh not found`);
                }
            }
        }

        const setUpMainScreen = async function(data = {
            text1: "Text1",
            text2: "Text2",
            text3: "Text3",
            text4: "Text4",
            text5: "Text5",
            text6: "Text6",
            backgroundImgUrl: null,
            teamLogoBackgroundImgUrl: null,
            playerImgUrl: null

        }) {
            const font1 = new FontFace("KenyanCoffeeRg-BoldItalic", "url('./fonts/kenyan_coffee_bd_it-webfont.woff2') format('woff2'), url('./fonts/kenyan_coffee_bd_it-webfont.woff') format('woff')");
            const font2 = new FontFace("KenyanCoffeeRg-Bold", "url('./fonts/kenyan_coffee_bd-webfont.woff2') format('woff2'), url('./fonts/kenyan_coffee_bd-webfont.woff') format('woff')");

            const canvas = document.createElement('canvas');
            canvas.width = 3840;
            canvas.height = 1080;
            const ctx = canvas.getContext('2d');

            // Draw Background
            const backgroundImg = new Image();
            backgroundImg.crossOrigin = "anonymous";
            backgroundImg.src = data.backgroundImgUrl || './tex/main_screen_background.png';
            await backgroundImg.decode();
            ctx.drawImage(backgroundImg, 0, 0, 3840, 1080);
            // Draw Player Background
            const teamLogoBgImg = new Image();
            teamLogoBgImg.crossOrigin = "anonymous";
            teamLogoBgImg.src = data.teamLogoBackgroundImgUrl || './tex/main_screen_teamlogo_background.png';
            await teamLogoBgImg.decode();
            ctx.globalAlpha = 0.59;
            ctx.drawImage(teamLogoBgImg, 1153, 432, 656, 659);
            ctx.globalAlpha = 1.0;

            await font1.load();
            document.fonts.add(font1);
            console.log('Font loaded');

            // Draw First Name
            ctx.font = '257px "KenyanCoffeeRg-BoldItalic"';
            ctx.fillStyle = "#FFFFFF";
            ctx.textAlign = "left";
            ctx.shadowColor = "rgba(2,11,57,0.33)";
            ctx.shadowOffsetX = 27;
            ctx.shadowOffsetY = 27;
            ctx.shadowBlur = 0;
            ctx.fillText(data.text1 || "", 1180, 336);

            // Draw Last Name
            ctx.font = '309px "KenyanCoffeeRg-BoldItalic"';
            ctx.strokeStyle = "#00f6ff";
            ctx.lineWidth = 6;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowColor = "#00f6ff";
            ctx.shadowBlur = 30;
            ctx.strokeText(data.text2 || "", 1127, 600);

            // Draw Player Number
            ctx.font = '556px "KenyanCoffeeRg-BoldItalic"';
            ctx.strokeStyle = "#00f6ff";
            ctx.lineWidth = 6;
            ctx.strokeText(data.text3 || "", 647, 576);

            await font2.load();
            document.fonts.add(font2);
            console.log('Font loaded');

            // Draw Stats
            ctx.font = '288px "KenyanCoffeeRg-Bold"';
            ctx.fillStyle = "#FFFFFF";
            ctx.shadowColor = "rgba(2,11,57,0.33)";
            ctx.shadowOffsetX = 27;
            ctx.shadowOffsetY = 27;
            ctx.shadowBlur = 0;
            ctx.fillText(data.text4 || "", 3100, 380);
            ctx.fillText(data.text5 || "", 3100, 676);
            ctx.fillText(data.text6 || "", 3100, 959);

            // Draw Player Image
            const playerImg = new Image();
            playerImg.crossOrigin = "anonymous";
            playerImg.src = data.playerImgUrl || './tex/main_screen_playerimage.png';
            await playerImg.decode();
            ctx.drawImage(playerImg, -7, -6, 1336, 1130);

            const screenMesh = scene.getMeshById("screen_1");
            const base64 = canvas.toDataURL();
            screenMesh.material.albedoTexture.updateURL(base64);
            screenMesh.material.emissiveTexture.updateURL(base64);
        }

        const loadData = function(gameEventId, type) {
            if (!runtime.loaded) {
                console.warn("Scene has not been loaded yet");
                return;
            }

            const url = `//shotv1.4natic.online/v1/data/stats/games/${gameEventId}/shots`;
            const data = fetch(url)
                .then((response) => response.json())
                .then((responseData) => {
                    if (type == 'shots') {
                        setUpSegments();
                        clearShots();
                        runtime.shots = responseData.shots.map((shot) => prepareShot(shot))
                    } else if (type == 'zones') {
                        let data = {};

                        responseData.shots.every((shot) => {
                            if (!("segment_" + shot.z in data)) {
                                data["segment_" + shot.z] = {
                                    missed: 0,
                                    made: 0
                                };
                            }
                            if (shot.st == "MISS") {
                                data["segment_" + shot.z].missed++;
                            }
                            data["segment_" + shot.z].made++;
                            return true;
                        });

                        setUpSegments(data);
                    }
                });
        }

        const generateCircle = function(r1 = 0.5, r2 = 0.5, q = 12, plane = 'xy') {
            var p = [];
            let a = 2 * Math.PI / q; // arc of each section
            let b = 3 * a / 2; //offset
            for (let i = 0; i < q; i++) {
                let v;
                if (plane == 'xy') {
                    v = newV(r1 * Math.cos(i * a), r2 * Math.sin(i * a), 0)
                } else if (plane == 'xz') {
                    v = newV(r1 * Math.cos(i * a + b), 0, r2 * Math.sin(i * a + b))
                } else {
                    console.warn('plane is ' + plane)
                }
                p.push(vround(v, 3));
            }
            p.push(p[0]);
            return p;
        }

        const newV = function(x = 0, y = 0, z = 0) {
            return new BABYLON.Vector3(x, y, z);
        }

        const dround = function(f, d) {
            d = Math.round(d);
            if (d < -15 || d > 15) {
                return f;
            }
            if (d == 0) {
                return Math.round(f);
            }
            let s = Math.pow(10, d);
            let ff = s * f;
            return Math.round(ff) / s;
        }

        const vround = function(v, d) {
            let va = [];
            v.toArray(va);
            va.forEach((e, ndx) => {
                va[ndx] = dround(va[ndx], d);
            })
            return v.fromArray(va);
        }
    </script>
</body>

</html>